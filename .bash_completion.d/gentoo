# Gentoo Linux Bash Shell Command Completion
#
# $Id: gentoo,v 1.1 2007/01/13 16:50:54 awdeorio Exp $
#
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later

# also defined in bash_completion proper however, will produce command
# not found warnings when this is only enabled "locally" so we define it
# here as well.
have()
{
    unset -v have
    PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin type $1 >&/dev/null && have="yes"
}

#
# Retrieve PORTDIR/PORTDIR_OVERLAY location from user's make.conf or, if it
# is not defined there, from make.globals.
#
_portdir()
{
    sed -n -e '/^PORTDIR=/ { s/^[^=]\+="\?\([^"]\+\|\S\+\).*/\1/p ; q }' \
        /etc/make.{conf,globals} 2>/dev/null

    if [[ $1 == '-o' ]] ; then
        sed -n -e '/^PORTDIR_OVERLAY=/ { s/^[^=]\+="\?\([^"]\+\|\S\+\).*/\1/p ; q }' \
            /etc/make.conf 2>/dev/null
    fi
}

# like _pkgname but completes on package names only (no category)
_pkgname_only()
{
    local i pd
    local cur="$1"
    shift
    local dir="$@"

    COMPREPLY=($(compgen -W "$(\
        for pd in $dir ; do \
            builtin cd ${pd}; \
            for i in *-*/${cur}*; do \
                [[ -d ${i} ]] && { local x=${i##*/} ; echo ${x%-[0-9]*}; } \
            done ; \
        done)" -- ${cur}))
}

#
# This function completes package names.
#
# usage: pkgname <mode> <current-directory>
#
# Where mode is one of:
#   -A  Search all available packages (except for those in the overlays)
#   -I  Only search the installed packages
#
# TODO: Look at breaking this function out and making it a "universal"
#       category/package name completion function.
#
_pkgname()
{
    local mode cur portdir only
    mode="$1"
    cur="$2"
    portdir=$(_portdir -o)
    # Ignore '=' at the beginning of the current completion
    [[ ${cur:1:1} == "=" ]] && cur=${cur:2}
    [[ ${cur:0:1} == "=" ]] && cur=${cur:1}
    case $mode in
	-I)
	    # Complete either the category or the complete package name
	    if [[ $cur == */* ]]; then
		COMPREPLY=($(builtin cd /var/db/pkg; compgen -W "$(compgen -G "$cur*" )" -- $cur))
	    else
		COMPREPLY=($(builtin cd /var/db/pkg; compgen -W "$(compgen -G "$cur*" -S /)" -- $cur))
	    fi
	    # We may just have finished completing the category.
	    # Make sure there isn't anything more to complete now.
	    if [[ ${#COMPREPLY[@]} == 1 ]]; then
		COMPREPLY=($(builtin cd /var/db/pkg; compgen -W "$(compgen -G "$COMPREPLY*")" -- $cur))
	    fi

            if [[ -z "${COMPREPLY}" ]] ; then
                only=1
                _pkgname_only ${cur} /var/db/pkg
            fi
	    ;;
	-A)
	    # Complete either the category or the complete package name
	    if [[ $cur == */* ]]; then
	        # Once the category has been completed, it's safe to use ${portdir}
	        # to continue completion.
                COMPREPLY=($(\
                    for pd in ${portdir} ; do \
                        builtin cd ${pd}; \
                        compgen -W "$(compgen -G "${cur}*")" -- "${cur}" ; \
                    done))
	        # When we've completed most of the name, also display the version for
	        # possible completion.
	        if [[ ${#COMPREPLY[@]} -le 1 || ${cur:${#cur}-1:1} == "-" ]] && 
                    [[ ${cur} != */ ]]; then
		    # The portage cache is appropriate to complete specific versions from.
		    COMPREPLY=(${COMPREPLY[@]} $(\
                        for pd in ${portdir} ; do \
                            if [[ -d ${pd}/metadata/cache ]] ; then \
                                builtin cd ${pd}/metadata/cache; \
                                compgen -W "$(compgen -G "${cur}*")" -- "${cur}" ; \
                            fi ; \
                        done))
	        fi
	    else
		COMPREPLY=( $(compgen -W "$(\
                    for pd in ${portdir} ; do \
                        if [[ -d ${pd}/metadata/cache ]] ; then
                            builtin cd ${pd}/metadata/cache; \
                            compgen -G "$cur*" -S / ; \
                        fi ; \
                    done)" -- $cur) )
                if [[ ${#COMPREPLY[@]} == 1 ]]; then
		    COMPREPLY=($(compgen -W "$(\
                    for pd in ${portdir} ; do \
                        if [[ -d ${pd}/metadata/cache ]] ; then
                            builtin cd ${pd}/metadata/cache; \
                            compgen -G "$COMPREPLY*" ; \
                        fi ; \
                    done)" -- $cur))
	        fi
	    fi

            if [[ -z "${COMPREPLY}" ]] ; then
                only=1
                _pkgname_only ${cur} ${portdir}
            fi
	    ;;
	*)
	    # Somebody screwed up! :-)
	    ;;
    esac
    # 'equery' wants an '=' in front of specific package versions.
    # Add it if there is only one selected package and it isn't there already.
    if [[ ${#COMPREPLY[@]} == 1 && ${COMP_WORDS[COMP_CWORD]:0:1} != "=" ]]
    then
        [[ -z "${only}" ]] && COMPREPLY=("="$COMPREPLY)
    fi
}

#
# This is an helper function for completion of  "-o <list>" / "--option=<list>"
# kind of command lines options.
# 
# Usage: _list_compgen <current> <sep> <item1>[<sep><item2> ...]
# - <current>: what we have so far on the command line
# - <sep>: the separator character used in lists
# - <itemN>: a valid item
# Returns: the function outputs each possible completion (one per line),
# and returns 0. Typical usage is COMPREPLY=($(_list_compgen ...)).
#
# Note: items must not contain the <sep> character (no backslash escaping has 
# been implemented).
#
_list_compgen()
{
	# Read the three parameters. 
	local current="${1}" ; shift
	local sep="${1}" ; shift
	local items="${*}"

	# This is the maximum number of "<current><sep><other_item>" possible
	# completions that should be listed in case <current> is a valid list.
	# Setting it to a negative value means "no bound" (always list everything).
	# Setting it to 0 means "never list anything" (only suggest <sep>).
	# Setting it to a positive value N means "list up to N possible items, and
	# only suggest <sep> if there are more".
	# It is probably not worth a parameter, thus it will defaults to my 
	# prefered setting (1) if not already defined in the environment.
	local max_others_number=${max_others_number:-1}

	# Save IFS. The <sep> character will be used instead in the following.
	local saved_IFS="${IFS}"
	IFS="${sep}"

	# Split the current items list in two parts:
	# - current_item is the last one (maybe partial or even empty)
	# - prefix_item are items are the previous ones
	local current_item="${current##*${sep}}"
	local prefix_items="${current%${current_item}}"

	# Iterate through valid items to recognize those that are:
	# - partial matches of the <current_item>
	# - already used in the list prefix
	# - not used in the list prefix, and not an exact match of <current_item>
	# Also check whether the <current_item> is exactly a valid one.
	local matching_items
	local other_items
	local exact_match
	local my_item
	for my_item in ${items} ; do
		if [[ "${sep}${prefix_items}${sep}" == *"${sep}${my_item}${sep}"* ]] ; then
			# The item has already been used in the list prefix: ignore it.
			continue
		elif [[ "${my_item}" == "${current_item}" ]] ; then
			# The item _exactly_ matches the <current_item>: that means that we
			# will have to suggest some more items to add behind.
			exact_match=1
		elif [[ "${my_item}" == "${current_item}"* ]] ; then
			# The item matches the <current_item>: it will be a possible
			# completion. It will also be a possible additional item in case of
			# exact match.
			matching_items="${matching_items}${sep}${my_item}"
			other_items="${other_items}${sep}${my_item}"
		else
			# The item neither matches the <current_item> nor has been already
			# used: it will only be a possible additional item in case of exact
			# match.
			other_items="${other_items}${sep}${my_item}"
		fi
	done
	matching_items="${matching_items#${sep}}"
	other_items="${other_items#${sep}}"

	# Takes care of the case where <current_item> is not exactly valid but
	# there is only one matching item: force this completion, and handle it
	# just as an exact match.
	if [[ -z "${exact_match}" ]] \
	&& [[ "${matching_items}" != *"${sep}"* ]] ; then
		exact_match=1
		current="${current%${current_item}}${matching_items}"
		current_item="${matching_items}"
		matching_items=""
		other_items="${sep}${other_items}${sep}"
		other_items="${other_items/${sep}${current_item}${sep}/${sep}}"
		other_items="${other_items#${sep}}"
		other_items="${other_items%${sep}}"
	fi

	# List all possible completions. They are stored in an array.
	# XXX: maybe if should be COMPREPLY directly? (with no output at the end)
	local my_compreply=()
	local i=0
	if [[ -n "${exact_match}" ]] ; then
		# Found an exact match? Then add "<current>".
		my_compreply[${i}]="${current}"
		let i++
	fi
	if [[ -n "${matching_items}" ]] ; then
		# Found some matching items?
		# Then add "<prefix_items><matching_item>".
		for my_item in ${matching_items} ; do
			my_compreply[${i}]="${prefix_items}${my_item}"
			let i++
		done
	fi
	if [[ -n "${exact_match}" ]] \
	&& [[ -n "${other_items}" ]] ; then
		# Found an exact match and some other possible items remain?
		# First, count them:
		local count_others=0
		for my_item in ${other_items} ; do
			let count_others++
		done
		# Then decide how to behave depending on the max_others_number setting:
		if (( max_others_number < 0 )) \
		|| (( count_others <= max_others_number )) ; then
			# List the possible "<current><sep><other_item>" completions.
			for my_item in ${other_items} ; do
				my_compreply[${i}]="${current}${sep}${my_item}"
				let i++
			done
		else # Only suggest adding the <sep> character.
			my_compreply[${i}]="${current}${sep}"
			let i++
		fi
	fi

	# Restore IFS.
	IFS="${saved_IFS}"

	# Output the array of possible completions and returns.
	local j=0
	while (( i > j )) ; do
		echo ${my_compreply[$j]}
		let j++
	done
	return 0
}

#
# emerge completion command
#
have emerge && {
_emerge()
{
    local c cur prev curword numwords opts cond prepend
    local words stopre stophere i x
    local action actionpos actionre sysactions eactions pkgpos
    local version_mode searchdesc_mode help_mode resume_mode
    local portdir=$(_portdir -o)
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    numwords=${#COMP_WORDS[*]}
    curword=${COMP_CWORD}
    actionre='@(-?([A-Za-z]*)[CPcis]*|@(metadata|s@(y@(nc|stem)|earch)|regen|@(unmerg|prune)e|world|@(@(dep)@(clean)|@(in@(fo|ject)))))'
    stopre=' @(?(--)depclean|?(--)info|?(--)metadata|regen|sy@(nc|stem)|world|--@(resume|s@(kipfirst|ync)))'
    opts=''

    if [[ ${prev} == '>' || ${prev} == '<' ]] ; then
        COMPREPLY=($(compgen -f -- ${cur}))
        return 0
    fi

    # find action
    for x in ${COMP_LINE} ; do
        if [[ ${x} == ${actionre} ]] ; then
            action=${x}
            break
        fi
    done

    if [[ -n "${action}" ]]; then
	for ((i = 0; i < ${numwords}; i++ )); do
	    if [[ ${COMP_WORDS[${i}]} == "${action}" ]]; then
		actionpos=${i}
		pkgpos=$((actionpos + 1))
		break
	    fi
	done
        
        if [[ ${action} == -* && ${action} != --* ]] ; then
	    case "${action}" in
		-*C*) action='unmerge' ;;
		-*P*) action='prune' ;;
		-*c*) action='clean' ;;
		-*i*) action='inject' ;;
		-*s*) action='search' ;;
	    esac
	fi
    else
	for ((i = 1; i < ${numwords}; i++ )); do
	    if [[ ! "${COMP_WORDS[$i]}" == -* ]]; then
		pkgpos=${i}
		break
	    fi
	done
	[[ -n "${pkgpos}" ]] || pkgpos=${numwords}
    fi
	    
    # Check for special cases.
    [[ ${COMP_LINE} == *" "-@(V|-version)* ]] && version_mode=1
    [[ ${COMP_LINE} == *" "-@(S|-searchdesc)* ]] && searchdesc_mode=1
    [[ ${COMP_LINE} == *" "-@(h|-help)* ]] && help_mode=1
	    
    # Handle special cases.
    if [[ "${action}" == 'search' ]] || [[ -n "${searchdesc_mode}" ]] || \
        [[ -n "${version_mode}" ]] || [[ "${action}" == 'metadata' ]]
    then
        unset COMPREPLY
	return 0
    elif [[ -n "${help_mode}" ]]; then
	unset COMPREPLY
	[[ ${curword} -eq 2 ]] && COMPREPLY=($(compgen -W 'config sync system' -- ${cur}))
	return 0
    fi
	    
    # Complete on options.
    if [[ "${cur}" == -* ]]; then
        # If a resume option was specified, it needs special handling.
        [[ ${COMP_LINE} == *--@(resume|skipfirst)* ]] && resume_mode=1
	
        if [[ -n "${resume_mode}" ]]; then
	    if [[ "${cur}" == --* ]]; then
		opts="--ask --pretend --resume --skipfirst"
	    elif [[ "${cur}" == -* ]]; then
                [[ ${COMP_LINE} == *--@(ask|pretend)* ]] && ask_premode=1
                [[ -n "${ask_premode}" ]] && opts="-a -p"
	    fi
	elif [[ "${cur}" == --* ]]; then
	    # Complete on long options.
	    opts="--ask --autoclean \
		--buildpkg --buildpkgonly \
		--changelog --clean --columns \
		--debug --deep \
		--emptytree \
		--fetch-all-uri --fetchonly \
		--getbinpkg --getbinpkgonly \
		--newuse --noconfmem --nodeps --noreplace --nospinner
		--oneshot --onlydeps \
		--pretend \
		--quiet \
		--sync \
		--tree \
		--update --upgradeonly --usepkg --usepkgonly \
		--verbose --depclean --info --search"
	    if [[ ${curword} -eq 1 ]] && [[ ${numwords} -eq 2 ]] ; then
		opts="${opts} --help --resume --searchdesc --version"
	    fi
	elif [[ "${cur}" == -* ]]; then
	    # Complete on short options.
	    opts="-B -D -G -K -O -U -a -b -d -e -f -g -k -l -n -o -p -q -t -u -v"
	    if [[ ${curword} -eq 1 ]] && [[ ${numwords} -eq 2 ]] ; then
		opts="${opts} -h -S -V"
	    fi
	    if [[ -z "${action}" ]] && [[ ${curword} -eq $((pkgpos - 1)) ]] ; then
		opts="${opts} -C -P -c -i -s"
	    fi
	fi
		    
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
	
        # NOTE: This slows things down!
        # (Adapted from bash_completion by Ian Macdonald <ian@caliban.org>)
	# This removes any options from the list of completions that have
	# already been specified on the command line.
	COMPREPLY=($(echo "${COMP_WORDS[@]}" | \
            (while read -d ' ' i; do
		[[ "${i}" == "" ]] && continue
		# flatten array with spaces on either side,
		# otherwise we cannot grep on word boundaries of
		# first and last word
		COMPREPLY=" ${COMPREPLY[@]} "
		# remove word from list of completions
		COMPREPLY=(${COMPREPLY/ ${i%% *} / })
	    done
	    echo ${COMPREPLY[@]})))

	return 0
    fi
	
    # Stop completion if a special case is encountered.
    if [[ ${COMP_LINE} == *${stopre}* ]] ; then
        unset COMPREPLY
	return 0
    fi

    # Complete on installed packages when unmerging.
    if [[ "${action}" == 'unmerge' ]]; then
	if [[ -n "${cur}" ]] ; then
	    if [[ "${cur}" == */* ]]; then
		words=$(builtin cd /var/db/pkg; compgen -G "${cur}*")
	    else
		words=$(builtin cd /var/db/pkg; compgen -S '/' -G "${cur}*")

                local n=0
                for i in ${words} ; do
                    [[ ${i} == ${cur}* ]] && n=$((n+1))
                done

                if [[ ${n} -eq 1 ]] ; then
                    words="$(builtin cd /var/db/pkg ; compgen -G "*-*/*")"
                fi
	    fi
            COMPREPLY=($(for i in ${words} ; do \
                            [[ ${i} == ${cur}* ]] && echo ${i} ; \
                        done))
	else
	    COMPREPLY=($(builtin cd /var/db/pkg ; compgen -S '/' -G "*-*"))
	fi

        [[ -z "${COMPREPLY}" ]] && _pkgname_only ${cur} /var/db/pkg
        return 0
    fi
	
    # Check for conditional.
    cond="${cur%%[A-Za-z0-9]*}"
    cur="${cur:${#cond}}"
    if [[ ${cond:0:1} == "'" || ${cond:0:1} == '"' ]] ; then
        prepend="-P ${cond:1}"
        c="${cond:1}"
    else
        c="${cond}"
    fi
    
    # Handle cases where a conditional is specified.
    if [[ -n "${cond}" ]]; then
	if [[ -n "${cur}" ]]; then
            if [[ ${cur} == */* ]]; then
                if [[ ${cur} == *-[0-9]* ]] ; then
                    words="$(\
                        for pd in ${portdir} ; do \
                            builtin cd ${pd} ; \
                            local cat="${cur%/*}" ; \
                            local pkg="$(echo ${cur%-[0-9]*})" ; \
                            pkg="${pkg##*/}" ; \
                            for x in ${cat}/${pkg}/*.ebuild ; do \
                                [[ -f ${x} ]] || continue ; \
                                x="${x/${pkg}\/}" ; \
                                echo "${x%*.ebuild}" ; \
                            done ; \
                        done)"
                else
		    words="$(\
                    for pd in ${portdir} ; do \
                        builtin cd ${pd}; \
                        compgen -X "*metadata.xml" -G "${cur}*" -- ${cur} ; \
                    done)"
                fi

                local w
                for x in $words ; do
                    w="${x}\n${w}"
                done

                words=$(echo -ne ${w} | sort | uniq)
                COMPREPLY=( ${words} )
		
                # Complete on the specific versions (if appropriate).
                if [[ ${#COMPREPLY[@]} -le 1 ]] ; then
		    COMPREPLY=($(\
                        for pd in ${portdir} ; do \
                            if [[ -d ${pd}/metadata/cache ]] ; then
                                builtin cd ${pd}/metadata/cache; \
                                compgen ${prepend} -G "${cur}*" -- "${cur}" ; \
                            else \
                                builtin cd ${pd} ; \
                                local cat="${cur%/*}" ; \
                                local pkg="$(echo ${cur%-[0-9]*}*)" ; \
                                pkg="${pkg##*/}" ; \
                                for x in ${cat}/${pkg}/*.ebuild ; do \
                                    [[ -f "${x}" ]] || continue ; \
                                    x="${x/${pkg}\/}" ; \
                                    if [[ ${cond:0:1} == "'" ]] || \
                                        [[ ${cond:0:1} == '"' ]] ; then 
                                        echo "${c}${x%*.ebuild}" ; \
                                    else
                                        echo "${x%*.ebuild}" ; \
                                    fi ; \
                                done ; \
                            fi ; \
                        done))
                else
                    COMPREPLY=($(compgen ${prepend} -W "${words}" -- $cur))
                fi
            else
                words="$(\
                    for pd in ${portdir} ; do \
                        builtin cd ${pd} ; \
                        compgen ${prepend} -S '/' -G "${cur}*" -- "${cur}" ; \
                    done)"

                local w
                for x in words ; do
                    w="${x}\n${w}"
                done

                COMPREPLY=($(echo -e ${w} | uniq))
                [[ ${#COMPREPLY[@]} = 1 ]] && \
                    COMPREPLY=($(\
                        for pd in ${portdir} ; do \
                            builtin cd ${pd} ; \
                            compgen ${prepend} -G "${cur}*/*" -- "${cur}" ; \
                        done))
            fi
        else
	    words="$(\
                for pd in ${portdir} ; do \
                    builtin cd ${pd}; \
                    compgen -G "*-*"; \
                done)"
	    COMPREPLY=($(compgen -W "${words}" -- "${cur}"))
	fi
		
        # If all else fails, try to complete on package names without the
	# category being specified.
	if [[ -z "${COMPREPLY}" ]]; then
	    words="$(\
                for pd in ${portdir} ; do \
                    builtin cd ${pd}; \
                    for i in *-*/${cur}*; do \
                        [[ -d $i ]] && echo ${i##*/}; \
                    done ; \
                done)"

	    COMPREPLY=($(compgen ${prepend} -W "${words}" -- ${cur}))

	    if [[ ${#COMPREPLY[@]} -le 1 ]]; then
		# Now complete on the specific versions.
		words="$(\
                    for pd in ${portdir} ; do \
                        if [[ -d ${pd}/metadata/cache ]] ; then \
                            builtin cd ${pd}/metadata/cache; \
                            for i in */${cur}*; do \
                                [[ -f $i ]] && echo ${i##*/}; \
                            done ; \
                        fi ; \
                    done)"
		COMPREPLY=($(compgen ${prepend} -W "${words}" -- "${cur}"))
	    fi
	fi
	return 0
    fi
	
    # Complete on packages.
    if [[ ${COMP_CWORD} -eq 1 ]] ; then
	if [[ $numwords -le 2 ]]; then
	    sysactions=$'\n'"system"$'\n'"world"$'\n'"sync"$'\n'"metadata"
	else
	    sysactions=$'\n'"system"$'\n'"world"$'\n'"sync"
	fi
    else
	# Only allow these actions if no packages have been specified.
	#
	# TODO: This doesn't block these actions if no categories are
	#       specified. Please fix me.
	#
	#       e.g. emerge -a gentoo-dev-sources
	#
	#            will still allow system and world actions to be specified,
	#            as opposed to
	#
	#            emerge -a sys-kernel/gentoo-dev-sources
	#
	
        if [[ ! " ${COMP_LINE} " == *" "*[/]*" "* ]]; then
	    sysactions=$'\n'"system"$'\n'"world"
	else
	    sysactions=''
	fi
    fi
	
    if [[ -z "${action}" ]] && [[ ${curword} -le ${pkgpos} ]] ; then
        eactions=$'\n'"clean"$'\n'"depclean"$'\n'"inject"$'\n'"prune"$'\n'"regen"$'\n'"search"$'\n'"unmerge"
    fi
    if [[ -n "${cur}" ]] ; then
        if [[ ${cur} == virtual/* ]] ; then
            words=$(\
                for pd in ${portdir} ; do \
                    if [[ -d ${pd}/profiles ]] ; then
                        find ${pd}/profiles -name virtuals -exec \
                            sed -n -e 's|^\(virtual/[[:alnum:]]\+\).*$|\1|p' {} \; | \
                            sort -u
                    fi ; \
                done)
	elif [[ ${cur} == */* ]] ; then
	    words=$(\
                for pd in ${portdir} ; do \
                    builtin cd ${pd}; \
                    compgen -X "*metadata.xml" -G "${cur}*" ; \
                done)"${sysactions}""${eactions}"
	else
            local ww=$(\
                for pd in ${portdir} ; do \
                    builtin cd ${pd} ; \
                    compgen -S '/' -G "${cur}*"; \
                done)"${sysactions}""${eactions}"
            # complete on virtuals
            ww="${ww} $(\
                for pd in ${portdir} ; do \
                    if [[ -d ${pd}/profiles ]] ; then
                        find ${pd}/profiles -name virtuals -exec \
                            sed -n -e 's|^\(virtual/[[:alnum:]]\+\).*$|\1|p' {} \; | \
                            sort -u
                    fi ; \
                done)"

            local w
            for x in ${ww} ; do w="${x}\n${w}" ; done

            words=$(echo -e ${w} | sort -u)

            local n=0
            for i in ${words} ; do
                [[ ${i} == ${cur}* ]] && n=$((n+1))
            done

            if [[ ${n} -eq 1 ]] ; then
                words=$(for pd in ${portdir} ; do \
                            builtin cd ${pd} ; \
                            compgen -G "*-*/*" ; \
                        done)"${sysactions}""${eactions}"
            fi
        fi
        COMPREPLY=($(for i in ${words} ; do \
                        [[ ${i} == ${cur}* ]] && echo ${i} ; \
                    done))
    else
        words="$(\
            for pd in ${portdir} ; do \
                builtin cd ${pd} ; \
                compgen -S '/' -G "*-*" ; \
            done)""${sysactions}""${eactions}"
	COMPREPLY=($(compgen -W "${words}" -- ${cur}))
    fi

    # If all else fails, try to complete on package names without the
    # category being specified.
    if [[ -z "${COMPREPLY}" ]]; then
        words="$(\
            for pd in ${portdir} ; do \
                builtin cd ${pd}; \
                for i in [a-z]*-[a-z0-9]*/${cur}*; do \
                    [[ -d $i ]] && echo ${i##*/}; \
                done ; \
            done)"
	COMPREPLY=($(compgen -W "${words}" -- ${cur}))
    fi

    return 0
}
complete -o filenames -F _emerge emerge
}

#
# ebuild completion command
#
have ebuild && {
_ebuild()
{
    local cur opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"

    opts="help setup fetch digest manifest unpack compile test preinst \
    postinst install qmerge merge prerm postrm unmerge config package \
    rpm clean"

    if [[ $COMP_CWORD -eq 1 ]] ; then
	COMPREPLY=($(compgen -f -X "!*.ebuild" -- ${cur}) \
            $(compgen -d -- ${cur}) \
            $(compgen -W '--debug' -- ${cur}))
    
    elif [[ $COMP_CWORD -eq 2 && "${COMP_WORDS[1]}" = "--debug" ]] ; then
	COMPREPLY=($(compgen -f -X "!*.ebuild" -- ${cur}) $(compgen -d -- ${cur}))
    
    elif [[ $COMP_CWORD -ge 2 ]] ; then
	COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
    fi
    return 0
}
complete $filenames -F _ebuild ebuild
}

#
# Gentoo init.d completion
#

_gentoo_style_init()
{
    local script="${COMP_WORDS[0]}"
    local cur="${COMP_WORDS[$COMP_CWORD]}"

    if [[ ( -f "${script}" || -h "${script}" ) && -r "${script}" ]] \
	&& [[ "${script}" != *.sh ]] \
	&& [[ "$(head -n 1 "${script}")" = "#!/sbin/runscript" ]]
    then
	[[ $COMP_CWORD -gt 1 ]] && return 1
	COMPREPLY=($(opts="start stop status restart pause zap ineed needsme iuse usesme broken"; \
            eval "$(grep '^opts=' "${script}")"; echo "${opts}"))
	[[ -n "$COMPREPLY" ]] || COMPREPLY=(start stop restart zap)
	COMPREPLY=($(compgen -W "${COMPREPLY[*]}" -- "${cur}"))
    else
	COMPREPLY=($(compgen -o default -- "${cur}"))
    fi
    return 0
}
complete -F _gentoo_style_init /etc/init.d/*

#
# rc completion command
#
have rc && {
_rc()
{
    local cur
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    if [[ ${#COMP_WORDS[*]} -le 2 ]]; then
	COMPREPLY=($(compgen -W "$(for i in /etc/runlevels/*; do echo ${i##*/}; done)" -- $cur))
    fi
    return 0
}
complete -F _rc rc
}

#
# rc-status completion command
#
have rc-status && {
_rcstatus()
{
    local cur
    cur="${COMP_WORDS[COMP_CWORD]}"
    if [[ $COMP_CWORD -eq 1 ]]; then
        if [[ "${cur}" == --* ]]; then
	    COMPREPLY=($(compgen -W '--all --list --unused' -- ${cur}))
	elif [[ "${cur}" == -* ]]; then
	    COMPREPLY=($(compgen -W '-a -l -u' -- ${cur}))
	else
	    COMPREPLY=($(compgen -W "$(rc-status --list)" -- ${cur}))
	fi
    else
	unset COMPREPLY
    fi
    return 0
}
complete -F _rcstatus rc-status
}

#
# rc-update completion command
#
have rc-update && {
_rcupdate()
{
    local cur show
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    if [[ $COMP_CWORD -eq 1 ]]; then
	if [[ "${cur}" == -* ]]; then
	    COMPREPLY=($(compgen -W '-a -d -s' -- ${cur}))
	else
	    COMPREPLY=($(compgen -W 'add del show' ${cur}))
	fi
    else
        if [[ "${COMP_WORDS[1]}" == "show" ]] || [[ "${COMP_WORDS[1]}" == "-s" ]]; then
	    show="TRUE"
	fi
	if ([[ $COMP_CWORD -eq 3 ]] && [[ -z "$show" ]]) || \
            ([[ $COMP_CWORD -eq 2 ]] && [[ -n "$show" ]])
        then
	    COMPREPLY=($(compgen -W "$(for i in /etc/runlevels/*; do echo ${i##*/}; done)" -- $cur))
	elif [[ $COMP_CWORD -eq 2 ]]; then
	    COMPREPLY=($(compgen -X "*.@(c|sh|test)" -W "$(for i in /etc/init.d/*; do echo ${i##*/}; done)" $cur))
	elif [[ ${#COMP_WORDS[*]} -gt 2 ]] ; then
	    COMPREPLY=($(compgen -W "$(for i in /etc/runlevels/*; do echo ${i##*/}; done)" -- $cur))
	else
	    unset COMPREPLY
	fi
    fi
    return 0
}
complete -F _rcupdate rc-update
}

#
# gcc-config completion command
#
have gcc-config && {
_gcc_config() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="-O --use-old \
        -P --use-portage-chost \
        -c --get-current-profile \
        -l --list-profiles \
        -E --print-environ \
        -B --get-bin-path \
        -L --get-lib-path \
        -X --get-stdcxx-incdir"

    if [[ "${cur}" == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    elif [[ ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) \
            $(compgen -W "$(gcc-config -l | sed -r -e 's/(\[([^]]*)\]) //g')" \
                -- ${cur}) )
        return 0
    fi

    case "${prev}" in
        -O|--use-old|-P|--use-portage-chost|-c|--get-current-profile|-l|--list-profiles)
            COMPREPLY=()
            ;;
        *)
            COMPREPLY=( $(compgen -W "\
                $(gcc-config -l | sed -r -e 's/(\[([^]]*)\]) //g')" -- ${cur}) )
            ;;
    esac
}
complete -F _gcc_config gcc-config
}

#
# distcc-config completion command
#
have distcc-config && {
_distccconfig()
{
    local cur curword numwords opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    numwords=${#COMP_WORDS[*]}
    curword=${COMP_CWORD}
    if [[ ${numwords} -gt 3 ]]; then
	unset COMPREPLY
	return 0
    fi
    if [[ "${cur}" == -* ]] || [ ${curword} -eq 1 ]; then
	if [[ ${numwords} -le 2 ]] && [[ ${curword} -eq 1 ]]; then
	    opts="--get-hosts \
		--get-verbose \
		--get-log \
		--set-hosts \
		--set-verbose \
		--set-log \
		--add-path \
		--no-path"
	else
	    opts=""
	fi
    else
	opts=""
    fi
    COMPREPLY=($(compgen -W "${opts}" | grep ^$cur))
    return 0
}
complete -F _distccconfig distcc-config
}

#
# java-config completion command
#
have java-config && {
_javaconfig()
{
    local cur prev curword numwords opts args arg spec flag sedcmd grepcmd
    local multiplepkgs pkgs execopts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    numwords=${#COMP_WORDS[*]}
    curword=${COMP_CWORD}
    opts=""
    args=""
    pkgs=""
    sedcmd="sed -r -e s/\[([^]]+)\].*/\1/"
    vmsedcmd="sed -r -e s/\[([^]]+)\]/\1/"
    grepcmd="egrep -o (--set-(system|user)-(classpath|vm)=)"
    multiplepkgs=""
    execopts="HtmlConverter JavaPluginControlPanel \
	appletviewer awt_robot \
	extcheck \
	idlj \
	j2sdk-config jar jarsigner \
	java java-rmi.cgi java_vm javac javadoc javah javap jdb \
	keytool kinit klist ktab \
	native2ascii \
	oldjava oldjavac oldjdb orbd \
	policytool \
	realpath rmic rmid rmiregistry \
	serialver servertool \
        tnameserv"
    if [[ "${cur}" == -* ]] || [ ${curword} -eq 1 ]; then
	case "${cur}" in
	    --java)
		opts="--java --javac --java-version"
		;;
	    --j@(a@(r|va@(c|-version))|@(dk|re)-home))
		opts=""
		;;
	    --list-available-@(packages|vms))
		opts=""
		;;
	    --@(exec|set-@(user|system)-@(classpath|vm)))
		opts="${cur}="
		;;
	    --set-@(user|system)-@(classpath|vm)=)
		if [[ "${cur}" == "--set-system-vm=" ]] || [[ "${cur}" == "--set-user-vm=" ]]; then
		    flag="--list-available-vms"
		    args=$(java-config --nocolor "${flag}" | cut --delimiter=' ' --fields=2 | ${vmsedcmd})
		else
		    flag="--list-available-packages"
		    args=$(java-config --nocolor "${flag}" | ${sedcmd})
		fi
		for arg in ${args}; do
		    [[ -n "${opts}" ]] && opts="${opts} ${arg}" || opts="${arg}"
		done
		COMPREPLY=($(compgen $nospace -W "${opts}"))
		return 0
		;;
	    --exec=)
		COMPREPLY=($(compgen $nospace -W "${execopts}"))
		return 0
		;;
	    *)
	        if [[ "${cur}" == "--set-system-vm="* ]] || [[ "${cur}" == "--set-user-vm="* ]]; then
		    args=$(java-config --nocolor --list-available-vms | cut --delimiter=' ' --fields=2 | ${vmsedcmd})
		    if [[ "${cur}" == "--set-system-vm="* ]]; then
			spec=${cur##--set-system-vm=}
		    else
			spec=${cur##--set-user-vm=}
		    fi
		    for arg in ${args}; do
			if [[ "${arg:0:${#spec}}" == "${spec}" ]]; then
			    [[ -n "${opts}" ]] && opts="${opts} ${arg}" || opts="${arg}"
			fi
		    done
		    [[ "${opts}" == "${spec}" ]] && opts=""
		    COMPREPLY=($(compgen -W "${opts}"))
		    return 0
		elif [[ "${cur}" == "--set-system-classpath="* ]] || [[ "${cur}" == "--set-user-classpath="* ]]; then
		    args=$(java-config --nocolor --list-available-packages | ${sedcmd})
		    [[ $(echo "${cur}" | grep -c ",") -gt 0 ]] && multiplepkgs="true"
		    if [[ "${cur}" == "--set-system-classpath="* ]]; then
			spec="${cur##--set-system-classpath=}"
		    else
			spec="${cur##--set-user-classpath=}"
		    fi
		    if [[ -n "${multiplepkgs}" ]]; then
			pkgs="${spec%,*}"
			spec="${spec##*,}"
		    fi
		    if [[ -n "${multiplepkgs}" ]]; then
		        for arg in ${args}; do
			    if [[ "${spec}" ]]; then
			        if [[ "${arg:0:${#spec}}" == "${spec}" ]] \
			            && [[ ! $(echo "${cur}" | egrep -o "(=|,)${arg},") ]]
                                then
				    [[ -n "${opts}" ]] && opts="${opts} ${pkgs},${arg}" || opts="${pkgs},${arg}"
			        fi
			    else
			        if [[ ! $(echo "${cur}" | egrep -o "(=|,)${arg},") ]]; then
			            [[ -n "${opts}" ]] && opts="${opts} ${pkgs},${arg}" || opts="${pkgs},${arg}"
			        fi
			    fi
		        done
			[[ "${opts}" == "${pkgs},${spec}" ]] && opts=""
		    else
		        for arg in ${args}; do
			    if [[ "${spec}" ]] && [[ "${arg:0:${#spec}}" == "${spec}" ]]; then
				[[ -n "${opts}" ]] && opts="${opts} ${arg}" || opts="${arg}"
			    fi
			done
			[[ "${opts}" == "${spec}" ]] && opts=""
		    fi
		    COMPREPLY=($(compgen -W "${opts}"))
		    return 0
		elif [[ "${cur}" == "--exec="* ]]; then
		    spec=${cur##--exec=}
		    for arg in ${execopts}; do
			if [[ "${arg:0:${#spec}}" == "${spec}" ]]; then
			    [[ -n "${opts}" ]] && opts="${opts} ${arg}" || opts="${arg}"
			fi
		    done
		    [[ "${opts}" == "${spec}" ]] && opts=""
		    COMPREPLY=($(compgen -W "${opts}"))
		    return 0
		else
		    opts="--classpath --clean-system-classpath --clean-user-classpath \
		        --exec \
			--full-classpath \
		        --jar --java --javac --java-version --jdk-home --jre-home \
		        --list-available-packages --list-available-vms \
			--nocolor \
			--set-system-classpath --set-system-vm --set-user-classpath --set-user-vm"
		    [[ "$prev" == "--nocolor" ]] && opts="${opts/--nocolor}"
		fi
	        ;;
        esac
    elif [[ "$prev" == "--nocolor" ]] && [ ${curword} -eq 2 ] && [ $numwords -le 3 ]; then
	opts="--classpath --clean-system-classpath --clean-user-classpath \
	    --exec \
	    --full-classpath \
	    --jar --java --javac --java-version --jdk-home --jre-home \
	    --list-available-packages --list-available-vms \
	    --set-system-classpath --set-system-vm --set-user-classpath --set-user-vm"
    fi
    COMPREPLY=($(compgen $nospace -W "${opts}" -- ${cur}))
    return 0
}
complete $nospace -F _javaconfig java-config
}

#
# opengl-update completion command
#
have opengl-update && {
_openglupdate()
{
    local cur
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    if [[ ${#COMP_WORDS[*]} -le 2 ]]; then
	COMPREPLY=($(compgen -W "$(for i in /usr/lib/opengl/*; do [ -d $i ] && echo ${i##*/}; done)" $cur))
    else
        unset COMPREPLY
    fi
    return 0
}
complete -F _openglupdate opengl-update
}

#
# browser-config completion command
#
have browser-config && {
_browserconfig()
{
    local cur prev
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    if [[ ${COMP_CWORD} -eq 1 ]]; then
	COMPREPLY=($(compgen -W '-b -h -m' -- ${cur}))
    elif [[ "${prev}" == "-b" ]]; then
	COMPREPLY=($(compgen -W "$(for i in /usr/share/browser-config/*; do [ -f $i ] && echo ${i##*/}; done)" $cur))
    elif [[ "${prev}" == "-m" ]]; then
        COMPREPLY=($(compgen -W "same_window new_window new_tab new_browser" -- ${cur}))
	if [[ -z "${COMPREPLY}" ]]; then
	    COMPREPLY=''
	fi
    else
	unset COMPREPLY
    fi
    return 0
}
complete -F _browserconfig browser-config
}

#
# Bash completion for the Gentoo 'equery' command
#
have equery && {
_equery()
{
    local cur prev mode portdir i j
    portdir=$(_portdir)
    mode="GLOBAL"
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    # Find out what we're currently doing here.
    j=0
    for i in "${COMP_WORDS[@]}"; do
        if [[ $j -lt $COMP_CWORD ]]; then
	    j=$((j + 1))
	    case $i in
                @(belongs|ch@(anges|eck)|dep@(ends|graph)|files|glsa|list|s@(ize|tats)|uses|which|hasuse|b|c|k|d|g|f|a|h|l|s|t|u|w))
		    mode=$i
		    ;;
	    esac
	fi
    done
    # Now get to work.
    case $mode in
	GLOBAL)
	    # Complete commands and global options.
	    case $cur in
		-*)
		    COMPREPLY=($(compgen -W "-q --quiet -C --nocolor -h --help -V --version" -- $cur))
		    ;;
		*)
		    COMPREPLY=($(compgen -W "belongs changes check depends depgraph files glsa hasuse list size stats uses which" -- $cur))
		    ;;
	    esac
	    ;;
	c?(hanges)|a|glsa|t|stats)
	    # These commands have not been implemented in 'equery' yet ...
	    echo -n "# Not implemented! "
	    ;;
	f?(iles))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
	    	# --filter=<list>: completion of the files types list
	    	if [[ ${prev} == "-f" || "${cur}" == "--filter="* ]] ; then
	    		COMPREPLY=($(_list_compgen "${cur#--filter=}" , \
	    		    dir,obj,sym,dev,fifo,path,conf,cmd,doc,man,info))
	    		return 0
	    	fi
		case $cur in
		    --f*) 
		    # don't handle --filter= with others to avoid space after the "="
			COMPREPLY=($(compgen -P "--filter=" \
				-W "dir obj sym dev fifo path conf cmd doc man info"))
			;;
		    -*)
			COMPREPLY=($(compgen -W "--help --timestamp --md5sum
                        --type --filter=" -- $cur))
			;;
		    *)
			# Only installed packages can have their files listed.
		        _pkgname -I $cur
			;;
		esac
	    fi
	    ;;
	l?(ist))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
		case "${cur}" in
		    -*)
			COMPREPLY=($(compgen -W "--help -i --installed -I --exclude-installed -p --portage-tree -o --overlay-tree" -- $cur))
			;;
		    *)
                        case "${prev}" in
                            -i|--installed)
                                _pkgname -I $cur
                                ;;
                            *)
			        # Complete on all package names.
			        _pkgname -A $cur
			        ;;
                        esac
                        ;;
		esac
	    fi
	    ;;
	b?(elongs))
	    # Only complete if the previous entry on the command line is not
	    # a file name.
	    if \
	        [[ \
		    ${prev} == ${mode} || \
		    ${prev:0:1} == "-" || \
		    ${COMP_WORDS[COMP_CWORD-2]} == "-c" || \
		    ${COMP_WORDS[COMP_CWORD-2]} == "--category" \
		]] && \
		[[ \
		    ${prev} != "-c" && \
		    ${prev} != "--category" \
		]]
	    then
		case $cur in
		    -*)
			    COMPREPLY=($(compgen -W "--help -c --category -e --earlyout" -- $cur))
			    ;;
		    *)
                COMPREPLY=($(compgen -f -- $cur) \
                    $(compgen -d -S '/' -- $cur))
			    ;;
		esac
	    # Are we completing a category?
	    elif [[ ${prev} == "-c" || ${prev} == "--category" ]]; then
		COMPREPLY=($(builtin cd ${portdir}/metadata/cache; compgen -W "$(compgen -G '*')" -- $cur))
	    fi
	    ;;
	@(u?(ses)|w?(hich)))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} ]]; then
	        # Complete on all package names.
	        _pkgname -A $cur
                COMPREPLY=($(compgen -W "${COMPREPLY[@]} --help" -- ${cur}))
	    fi
	    ;;
	g|depgraph)
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
	        case $cur in
		    -*)
		        COMPREPLY=($(compgen -W "--help -U --no-useflags -l --linear" -- $cur))
			;;
		    *)
			# Complete on installed package names.
			_pkgname -I $cur
			;;
		esac
	    fi
	    ;;
	d?(epends))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
		case $cur in
		    -*)
		        COMPREPLY=($(compgen -W "--help -a --all-packages -d --direct -D --indirect" -- $cur))
			;;
		    *)
			case $prev in
			    -a|--all-packages)
				# Complete on all package names.							
				_pkgname -A $cur
				;;
			    *)
				# Complete on installed package names.
			        _pkgname -I $cur
				;;
                        esac
                        ;;
		esac
	    fi
	    ;;
	k|check)
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} ]]; then
		# Only installed packages can have their integrity verified.
		_pkgname -I $cur
                COMPREPLY=($(compgen -W "${COMPREPLY[@]} --help" -- ${cur}))
	    fi
	    ;;
	s?(ize))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
		case $cur in
		    -*)
			COMPREPLY=($(compgen -W "--help -b --bytes" -- $cur))
			;;
		    *)
			# Only installed packages can have their size calculated.
			_pkgname -I $cur
			;;
		esac
	    fi
	    ;;
        h?(asuse))
	    # Only complete if the previous entry on the command line is not
	    # a package name.
	    if [[ ${prev} == ${mode} || ${prev:0:1} == "-" ]]; then
	        case $cur in
	            -*)
		        COMPREPLY=($(compgen -W "--help -i --installed -I --exclude-installed -p --portage-tree -o --overlay" -- $cur))
		        ;;
	            *)
		        local glob loc
                        [[ -f ${portdir}/profiles/use.desc ]] || return 0
                        [[ -f ${portdir}/profiles/use.local.desc ]] || return 0
		        glob=$(sed -n -e 's/^\([^ ]\+\) - .*$/\1/p' ${portdir}/profiles/use.desc)
		        loc=$(sed -n -e 's/^[^ ]\+:\([^ ]*\) - .*$/\1/p' ${portdir}/profiles/use.local.desc)
		        COMPREPLY=($(compgen -W "$glob $loc" -- $cur))
		        ;;
	        esac
            fi
            ;;
    esac
    return 0
}
complete -F _equery equery
}

#
# ekeyword completion
#

have ekeyword && {
_ekeyword()
{
    local cur portdir archl_s archl_u archl_r archl_m arch
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    portdir=$(_portdir)

    [[ -f ${portdir}/profiles/arch.list ]] || return 0

    for arch in all $(< ${portdir}/profiles/arch.list) ; do
	archl_m="${archl_m} -${arch}"
	archl_u="${archl_u} ~${arch}"
	archl_r="${archl_r} ^${arch}"
	archl_s="${archl_s}  ${arch}"
    done

    case $cur in
	-*)
	    COMPREPLY=( $( compgen -W "${archl_m}" -- $cur ) )
	    ;;
	~*)
	    COMPREPLY=( $( compgen -W "${archl_u}" -- $cur ) )
	    ;;
	^*)
	    COMPREPLY=( $( compgen -W "${archl_r}" -- $cur ) )
	    ;;
	*)
	    if [ ${COMP_CWORD} -eq 1 ] ; then
		COMPREPLY=( $(compgen -W "${archl_s}" -- $cur ) )
	    else
		COMPREPLY=( $( compgen -W "${archl_s}" -- $cur ) )
		_filedir 'ebuild'
	    fi
	    ;;
    esac
}
complete $filenames -F _ekeyword ekeyword
}

#
# portageq completion
#

have portageq && {
_portageq() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="config_protect_mask \
	  config_protect \
	  vdb_path \
	  gentoo_mirrors \
	  all_best_visible \
	  match \
	  best_visible \
	  mass_best_visible \
	  has_version \
	  portdir \
	  envvar \
	  mass_best_version \
	  best_version \
	  pkgdir \
	  portdir_overlay \
	  distdir"
    
    if [[ $COMP_CWORD -eq 1 ]] ; then
	# would always be correct, but it's pretty slow...
	#COMPREPLY=($(compgen -W "$(portageq | grep '^   [[:lower:]]' | \
	#    sed -e 's/^.*[[:space:]]\([[:lower:]_]\+\)[[:space:]].*$/\1/')" \
	#    -- ${cur}))
	COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
    fi

    case "${prev}" in
	config*|vdb_path|gentoo_mirrors|*dir*)
	    COMPREPLY=()
	    ;;
	    
	# this also isn't the fastest, but I welcome an alternative method
	envvar)
	    COMPREPLY=($(compgen -W "$(env -i emerge -v --info | \
                sed -n -e '/^[[:upper:]].*=".*"/s/^\(.*\)=".*$/\1/p')" -- ${cur}))
	    ;;
	    
	*v@(isible|ersion)|match)
	    COMPREPLY=($(compgen $nospace -W '/' -- $cur))
	    ;;
	
	# $prev is a path, so complete on category/package
	*/*)
            local x a=0
            for x in ${COMP_WORDS[@]} ; do
                # This is the only one 
                if [[ "${x}" == "all_best_visible" ]] ; then
                    a=1
                    break
                fi
            done

            if [[ ${a} -eq 1 ]] ; then
                COMPREPLY=()
            else
                # Check for conditional.
#                cond="${cur%%[A-Za-z0-9]*}"
#                cur="${cur:${#cond}}"

#                if [[ -n "${cond}" ]] ; then
#                    _pkgname -A $cur
#                else
                    _pkgname -A $cur
#                fi
            fi
	    ;;	    
    esac	
}

complete -F _portageq portageq
}

#
# webapp-config completion
#

have webapp-config && {
_webapp_complete_appver()
{
    local x proot ibase cur="$2"
    eval $(. /etc/vhosts/webapp-config ; \
	    echo proot="${MY_PERSISTROOT:-/var/db/webapps}" ; \
	    echo ibase="${WA_INSTALLSBASE:-installs}")

    case "$1" in
	# complete on installed
	installed)
	    COMPREPLY=($(compgen -W "$(\
		for x in ${proot}/*/*/installs ; do \
		    if [[ -f "${x}" ]] ; then \
			local y="${x%/*}" ; \
			y="${y%/*}" ; \
			echo "${y##*/}" ; \
		    fi ; \
		done)" -- ${cur}))
	    ;;
	    
	# complete on uninstalled
	uninstalled)
	    COMPREPLY=($(compgen -W "$(\
		for x in ${proot}/*/* ; do \
		    if [[ ! -f "${x}/${ibase}" ]] ; then \
			local y="${x%/*}" ; \
			echo "${y##*/}" ; \
		    fi ; \
		done)" -- ${cur}))
	    ;;
	    
	# all
	all)
	    COMPREPLY=($(compgen -W "$(\
		for x in ${proot}/* ; do \
		    [[ -d "${x}" ]] && echo "${x##*/}" ; \
		done)" -- ${cur}))
	    ;;
	    
	# complete on version
	*)
	    [[ -d "${proot}/$1" ]] || return 1
	    COMPREPLY=($(compgen -W "$(\
		for x in ${proot}/$1/* ; do \
		    [[ -d "${x}" ]] && echo "${x##*/}" ; \
		done)" -- ${cur}))
	    ;;
    esac
}

_webapp_config()
{
    local cur prev actions opts hostroot
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    actions="-I --install -U --upgrade -C --clean --list-installs \
	--list-unused-installs --show-installed --show-postinst \
	--help -v --version"
    opts="--bug-report --pretend -p -u --user -g --group \
	-d --dir -h --host -V --verbose --soft --secure --virtual-dirs \
	--virtual-files --force-virtual"

    eval $(. /etc/vhosts/webapp-config ; \
	echo hostroot="${VHOST_ROOT:-/var/www}")

    # --bug-report, --pretend, and -p can only be used as first arg
    if [[ ${COMP_CWORD} -gt 1 ]] ; then
	    opts="${opts/--bug-report --pretend -p}"
    fi

    if [[ "${cur}" == -* ]] || [[ ${COMP_CWORD} -eq 1 ]] ; then
	    COMPREPLY=($(compgen -W "${opts} ${actions}" -- ${cur}))
	    return 0
    fi
    
    case "${prev}" in
	    --bug-report|-p|--pretend)
		COMPREPLY=($(compgen -W "${opts} ${actions}" -- ${cur}))
		;;

	    -I|--install)
	        _webapp_complete_appver all ${cur}
	        ;;

	    -U|--upgrade)
	        _webapp_complete_appver installed ${cur}
	        ;;

	    # only complete on -d since it is required if -C is specified
	    -C|--clean)
	        COMPREPLY=($(compgen -W "-d" -- ${cur}))
	        ;;

	    --list-unused-installs)
	        _webapp_complete_appver uninstalled ${cur}
	        ;;
	    
	    --list-installs|--show-postinst)
	        _webapp_complete_appver all ${cur}
	        ;;
    
	    #  hrm... anyone know a better way to reliably do this?
	    -h|--host)
	        local x
	        COMPREPLY=($(compgen -W "$(\
		        for x in ${hostroot}/* ; do \
		            [[ -d "${x}" ]] && echo "${x##*/}" ; \
		        done)" -- ${cur}))
	        ;;
	    
	    --virtual*)
	        COMPREPLY=($(compgen -W "server-owned config-owned virtual" \
		    -- ${cur}))
	        ;;
		
	    -d|--dir)
		local host x i=0
                # see if --host has been specified, and if so, get the value
                # that was passed to it.
		for x in ${COMP_WORDS[@]} ; do
		    if [[ "${x}" == "-h" || "${x}" == "--host" ]] ; then
			host="${COMP_WORDS[((i+1))]}"
			break
		    fi
		    i=$((i+1))
		done

                # otherwise, use the default host
		if [[ "${host}" == "" ]] ; then
		    eval $(. /etc/vhosts/webapp-config ; \
			echo host="${VHOST_HOSTNAME:-localhost}")
		fi
		
	        COMPREPLY=($(compgen -W "$(\
		    for x in ${hostroot}${host}/* ; do \
			[[ -d "${x}" ]] && echo "${x}" ; \
		    done)" -- ${cur}))
	        ;;
	    -u|--user)
	        COMPREPLY=($(compgen -u -- ${cur}))
	        ;;
	    -g|--group)
	        COMPREPLY=($(compgen -g -- ${cur}))
	        ;;

	    # we haven't recognized it yet, so more than likely ${prev}
	    # is a 'app-name' ; assuming it is indeed a valid 'app-name'
	    # (_webapp_complete_appver does the check), complete on available
	    # 'app-version's
	    *)
	        _webapp_complete_appver ${prev} ${cur} || \
                    _webapp_complete_appver all ${cur}
	        ;;
    esac
}
complete -F _webapp_config webapp-config
}

#
# etcat completion
#

have etcat && {
_etcat()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="-b belongs -c changes -d depends -f files -s size -u uses -v
    versions"

    if [[ ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        -b|belongs)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -c|changes|-v|versions)
            _pkgname -A ${cur}
            ;;
        -d|depends)
            # kinda hard to complete on a regex...
            COMPREPLY=()
            ;;
        -f|files|-s|size|-u|uses)
            _pkgname -I ${cur}
            ;;
        *)
            local x b=0
            for x in ${COMP_WORDS[@]} ; do
                [[ ${x} == "-b" || ${x} == "belongs" ]] && b=1
            done

            if [[ ${b} -eq 1 ]] ; then
                local portdir=$(_portdir)
                COMPREPLY=($(compgen -W "$(< ${portdir}/profiles/categories)" -- ${cur}))
            fi
            ;;
    esac
}
complete -o filenames -F _etcat etcat
}

have revdep-rebuild && {
_revdep_rebuild() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="-X --package-names --soname --soname-regexp -q --quiet"

    if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] || \
        [[ ${prev} == @(-q|--quiet) ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        -X|--package-names)
            _pkgname -I ${cur}
            ;;
        --soname)
            local sonames=$(for x in /lib/*.so?(.)* /usr/lib*/*.so?(.)* ; do \
                                echo ${x##*/} ; \
                            done)
            COMPREPLY=($(compgen -W "${sonames}" -- ${cur}))
            ;;
        --soname-regexp)
            COMPREPLY=()
            ;;
        *)
            if [[ ${COMP_LINE} == *" "@(-X|--package-names)* ]] ; then
                _pkgname -I ${cur}
                COMPREPLY=(${COMPREPLY[@]} $(compgen -W "${opts}"))
            else
                COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
            fi
            ;;
    esac
}
complete -F _revdep_rebuild revdep-rebuild
}

have splat && {
_splat() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="-h --help -v --verbose -s --summary -f --logfile -c --colored -l
    --list -u --count -p --package -t --sort -r --reverse"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        -f|--logfile)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            _pkgname -A ${cur}
            COMPREPLY=($(compgen -W "${COMPREPLY[@]} ${opts}" -- ${cur}))
            ;;
    esac
}
complete -o filenames -F _splat splat
}

have euse && {
_euse() {
    local cur prev opts sopts use portdir
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="-h --help -v --version -i --info -a --active -E --enable -D --disable
        -P --prune"
    sopts="-g --global -l --local"

    if [[ ${cur} == -* ]] && [[ ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        -h|--help|-v|--version)
            COMPREPLY=()
            ;;
        -a|--active)
            COMPREPLY=($(compgen -W "${sopts}" -- ${cur}))
            ;;
        -i|--info|-E|--enable|-D|--disable|-P|--prune)
            portdir=$(_portdir)
	    use="$(sed -n -e 's/^\([^ ]\+\) - .*$/\1/p' ${portdir}/profiles/use.desc) \
	    $(sed -n -e 's/^[^ ]\+:\([^ ]*\) - .*$/\1/p' ${portdir}/profiles/use.local.desc)"
	    COMPREPLY=($(compgen -W "${use} ${sopts}" -- ${cur}))
            ;;
        *)
            local l=0 g=0

            if [[ ${COMP_LINE} == *" "@(-l|--local)* ]] ; then
                l=1
            elif [[ ${COMP_LINE} == *" "@(-g|--global)* ]] ; then
                g=1
            fi

            if [[ ${COMP_LINE} == *" "@(-i|--info|-E|--enable|-D|--disable|-P|--prune)* ]]
            then
                portdir=$(_portdir)

                if [[ ${l} -eq 1 ]] ; then
                    use=$(sed -n -e 's/^[^ ]\+:\([^ ]*\) - .*$/\1/p' ${portdir}/profiles/use.local.desc)
                elif [[ ${g} -eq 1 ]] ; then
                    use=$(sed -n -e 's/^\([^ ]\+\) - .*$/\1/p' ${portdir}/profiles/use.desc)
                fi

                COMPREPLY=($(compgen -W "${use}" -- ${cur}))
            fi
    esac
}
complete -F _euse euse
}

have glsa-check && {
_glsa_check() {
    local cur opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    opts="-l --list -d --dump --print -t --test -p --pretend -f --fix -i
    --inject -n --nocolor -h --help -V --version -v --verbose"

    if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    # too slow otherwise
    if [[ ! -f ${ROOT}/tmp/gc.out ]] || \
        [[ $(stat ${ROOT}/tmp/gc.out | \
        sed -n -e 's/^Modify: \([[:digit:]]\+-[[:digit:]]\+-[[:digit:]]\+\).*$/\1/p') != "$(date +%F)" ]]
    then
        glsa-check -nl 2>/dev/null | \
            sed -n -e  's/^\([[:digit:]]\+-[[:digit:]]\+\) .*$/\1/p' > \
                ${ROOT}/tmp/gc.out
    fi

    COMPREPLY=($(compgen -W "${opts} $(< ${ROOT}/tmp/gc.out)" -- ${cur}))
}
complete -F _glsa_check glsa-check
}

have epm && {
_epm() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD]}"
    opts="-q --query -V -y --verify -e --erase --help"

    if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        --help)
            COMPREPLY=()
            ;;
        -q|--query)
            _pkgname -I ${cur}
            COMPREPLY=($(compgen -W "${COMPREPLY[@]} -l -f -G -a" -- ${cur}))
            ;;
        *)
            local x all=0 file=0
            for x in ${COMP_WORDS[@]} ; do
                [[ ${x} == -* ]] || continue
                [[ ${x} == *f* ]] && file=1
                [[ ${x} == *a* ]] && all=1
            done

            if [[ ${file} -eq 1 ]] ; then
                COMPREPLY=($(compgen -f -- ${cur}))
            elif [[ ${all} -eq 1 ]] ; then
                COMPREPLY=()
            else
                _pkgname -I ${cur}
            fi
            ;;
    esac
}
complete -o filenames -F _epm epm
}

# vim: set ft=sh tw=80 sw=4 et :
